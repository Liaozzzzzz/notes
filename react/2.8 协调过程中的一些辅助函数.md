# 协调过程中的一些辅助函数

1.deleteChild

标记child节点需要删除。

```javascript
function deleteChild(returnFiber: Fiber, childToDelete: Fiber): void {
    // shouldTrackSideEffects为false时，当前节点还没挂载， 不应该存在Deletion的副作用
    if (!shouldTrackSideEffects) {
      // Noop.
      return;
    }
    
    // returnFiber.lastEffect 重置为childToDelete
    const last = returnFiber.lastEffect;
    if (last !== null) {
      last.nextEffect = childToDelete;
      returnFiber.lastEffect = childToDelete;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
    }

    childToDelete.nextEffect = null;
    // effectTag标记Deletion的副作用
    childToDelete.effectTag = Deletion;
  }
```

2.deleteRemainingChildren
```javascript
function deleteRemainingChildren(
    returnFiber: Fiber,
    currentFirstChild: Fiber | null,
  ): null {
    if (!shouldTrackSideEffects) {
      // Noop.
      return null;
    }

    // 遍历所有兄弟节点, 都标记Deletion的副作用
    let childToDelete = currentFirstChild;
    while (childToDelete !== null) {
      deleteChild(returnFiber, childToDelete);
      childToDelete = childToDelete.sibling;
    }
    return null;
  }
```

3.useFiber
复制fiber
```javascript
function useFiber(fiber: Fiber, pendingProps: mixed): Fiber {
    // We currently set sibling to null and index to 0 here because it is easy
    // to forget to do before returning it. E.g. for the single child case.
    const clone = createWorkInProgress(fiber, pendingProps);
    clone.index = 0;
    clone.sibling = null;
    return clone;
  }
```